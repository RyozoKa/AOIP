// AOIP.cpp : Defines the exported functions for the DLL application.
//

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS





#ifdef WIN32

#define PACKED
#pragma pack(push,1)

#else
#define PACKED __attribute__ ((__packed__))
#endif

struct RTPHeader
{
	//first byte
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
	unsigned char         CC : 4;        /* CC field */
	unsigned char         X : 1;         /* X field */
	unsigned char         P : 1;         /* padding flag */
	unsigned char         version : 2;
#elif G_BYTE_ORDER == G_BIG_ENDIAN
	unsigned char         version : 2;
	unsigned char         P : 1;         /* padding flag */
	unsigned char         X : 1;         /* X field */
	unsigned char         CC : 4;        /* CC field*/
#else
#error "G_BYTE_ORDER should be big or little endian."
#endif
	union
	{
		//second byte
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
		unsigned char         PT : 7;     /* PT field */
		unsigned char         M : 1;       /* M field */
#elif G_BYTE_ORDER == G_BIG_ENDIAN
		unsigned char         M : 1;         /* M field */
		unsigned char         PT : 7;       /* PT field */
#else
#error "G_BYTE_ORDER should be big or little endian."
#endif
		unsigned char Type;
	};
	unsigned short              seq_num;      /* length of the recovery */
	unsigned int				TS;                   /* Timestamp */
	unsigned int				ssrc;

	unsigned char Data[];
}; //12 bytes

static_assert(sizeof(RTPHeader) == 12, "RTPHeader size doesn't seem to be cool.");



struct Ethernet
{
	unsigned char DestMAC[6];
	unsigned char SrcMAC[6];
	unsigned short Type;
};

struct IP4
{
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
	unsigned char IHL : 4;
	unsigned char Ver : 4;

	unsigned char ECN : 2;
	unsigned char DSCP : 6;

	unsigned short Len;	//Still in big endian

	unsigned short ID;

	unsigned short Flags;

#elif G_BYTE_ORDER == G_BIG_ENDIAN
	unsigned char Ver : 4;
	unsigned char IHL : 4;

	unsigned char DSCP : 6;
	unsigned char ECN : 2;

	unsigned short Len;

	unsigned short ID;

	unsigned char Flags : 3;
	unsigned short Frag : 13;


#else
#error "G_BYTE_ORDER should be big or little endian."
#endif

	unsigned char TimeToLive;
	unsigned char Protocol;
	unsigned short Checksum;
	unsigned int SourceIP;
	unsigned int DestIP;

};

static_assert(sizeof(IP4) == 20, "");


struct UDPHeader
{
	unsigned short SourcePort;			// Source port
	unsigned short DestPort;			// Destination port
	unsigned short Len;					// Datagram length
	unsigned short CRC;					// Checksum
};

struct FRAME
{
	Ethernet Eth;
	IP4 IPHdr;
	UDPHeader UDP;
	RTPHeader RTP;
};

struct PTPHeaderv1
{
	unsigned short	PVersion; //Transport Specific
	unsigned short	NetVersion; //PTP version
	char			SubDomain[16];
	unsigned char	MsgType;
	unsigned char	ComType;
	unsigned char	UUIDMAC[6];
	unsigned short	PortID;
	unsigned short	SqID;
	unsigned short	CtrlMsg;
	unsigned short	Flags;
	int				Padding;	//Don't use
	unsigned int	Seconds;
	unsigned int	NSeconds;
	unsigned short	EpochNum;
	unsigned short	UTCOffset;
	unsigned char	Padding2;
	unsigned char	MasterTech;
	unsigned char	MasterMAC[6];
	unsigned short	MasterPortID;
	unsigned short	MasterSqID;
	unsigned int	MasterStratum;
	char			ClockID[4];
	unsigned short	Padding4;
	short			ClockVariance;
	unsigned short	Preferred;
	unsigned short	IsBoundaryClock;
	unsigned char	Padding6[3];
	signed char		SyncInterval;
	unsigned short	Padding7;
	short			LocalClockVariance;
	unsigned short	Padding8;
	unsigned short	LocalStepsRemoved;	//!Not important
	unsigned int	LocalClockStratum;
	unsigned char	LocalClockID[4];
	unsigned short	ParentComID;
	unsigned char	ParentUUIDMAC[6];
	unsigned short	Padding9;
	unsigned short	ParentPortField;
	unsigned short  Padding10;
	unsigned short	EstimatedMasterVariance;
	unsigned int	EstimatedMasterDrift;
	unsigned int	UTCReasonable;
};

struct PTPHeaderv2
{

	unsigned short	PTPVersion;	//0x2

	unsigned short	Len;
	unsigned short	SubDomainNum;
	unsigned short	Flags;

	//Only for little endian!
	unsigned long long CorrectionSubNS : 16;
	unsigned long long CorrectionNS : 48;

	int					Padding;

	unsigned char		ClockID[8];
	unsigned short		SourcePortID;
	unsigned short		SqID;
	unsigned char		Control;
	unsigned char		LogMessagePeriod;

	unsigned char		Seconds[6];
	unsigned int		NanoSeconds;
};

#ifdef WIN32
#pragma pack(pop)
#undef PACKED

#else
#undef PACKED
#endif

#include "AOIP.h"
#include <stdio.h>
#include <intrin.h>
#include <powerbase.h>
#include <powrprof.h>
#include <assert.h>
#include <thread>
#include <iostream>
#include <iphlpapi.h>
#include "pcap.h"
#include <string>
//Packet offset for RTP header
#define RTPOFFSET 42
#define PAYLOADOFFSET 54
#define RTPTSOFFSET 46

//Declarations
NTSTATUS
WINAPI
CallNtPowerInformation(
	_In_ POWER_INFORMATION_LEVEL InformationLevel,
	_In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength
);


unsigned long long GetQPC()
{
	LARGE_INTEGER cnt;
	QueryPerformanceCounter((LARGE_INTEGER*)&cnt);
	return cnt.QuadPart;
}

unsigned long long rdtsc()	//Function stub
{
	return __rdtsc();
}

unsigned long StringToIP(const char* IP)	//IPv4 only
{
	union
	{
		unsigned char Bytes[4];
		unsigned long Data;
	};
	unsigned char Index = 0;
	while (Index < 4)
	{
		if (IP[1] == '.' || IP[1] == 0)	//X.
		{
			Bytes[Index] = IP[0] - '0';
			IP += 2;
		}
		else if (IP[2] == '.' || IP[2] == 0)
		{
			Bytes[Index] = ((IP[0] - '0') * 10) + (IP[1] - '0');
			IP += 3;
		}
		else if (IP[3] == '.' || IP[3] == 0)
		{
			Bytes[Index] = ((IP[0] - '0') * 100) + ((IP[1] - '0') * 10) + (IP[2] - '0');
			IP += 4;
		}
		else return 0;
		++Index;
	}
	return Data;
}
//Fast String to number converter and pow10
unsigned long long StaticPow10(BYTE num)
{
	static UINT64 pow10s[19] = {
	1,
	10,
	100,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	1000000000,
	10000000000,
	100000000000,
	1000000000000,
	10000000000000,
	100000000000000,
	1000000000000000,
	10000000000000000,
	100000000000000000,
	1000000000000000000
	};
	return pow10s[num];
}

signed long long ToNum(char *st)
{
	bool bNeg = false;
	INT64 num = 0;
	if (*st == '-')
	{
		bNeg = true;
		++st;
	}
	size_t len = strlen(st);
	for (int i = len - 1; i >= 0; --i)
	{
		num += StaticPow10(i) * (*st - '0');
		++st;
	}
	if (bNeg)
		num = ~num + 1;
	return num;
}

//Control signals
std::thread SAPThread;
std::thread RTPThread;
bool bSAPTrans = false;	//Don't transmit SAP by default
bool bSAPMain = false;
bool bRTPMain = false;
bool bRTPTrans = false;

//Store the last configuration made
double IntervalFreq;
unsigned long SAPIPAddr;
float *OutBuffer;
unsigned char SampleDelay;
timer Timer;

SOCKET SAPSocket;
SOCKADDR_IN SAPAddr;
SOCKADDR_IN SAPInAddr;


pcap_t *listener;			//RTP and PTP receive handle
pcap_t* RTPpcap;			//RTP transmission handle
pcap_t *SAPlst;				//SAP receive handle


AOIP_API SDP Streams[128];
AOIP_API SDP TransmissionStreams[32];
AOIP_API unsigned char NumTStreams = 0;

//Channel ring buffer
__declspec(align(32)) std::atomic<float> ChannelData[128][128]{ 0 };
std::atomic<unsigned short> GStepperIndex (0);
//std::atomic<unsigned short> GStepperIndex = 0;
AOIP_API std::atomic<unsigned short> ChannelCount (0);

AOIP_API unsigned char Index = 0;
unsigned char NumDevs = 0;	//Stream counter, Index does not necessarily represent the number of connected devices once a device is disconnected.
Interface* SelectedInterface;

char PCErr[PCAP_ERRBUF_SIZE];
const char* DevName;

unsigned char IPPrefix = 69;	//Default dante prefix
bool bUpdateTS = true;

unsigned long long (*GetTS)(void);

double PTPTimeStamp;
double Start;

double GetTSFreq()
{
	unsigned long long Res;
	int cpuInfo[4] = { 0, 0, 0, 0 };
	__cpuid(cpuInfo, 0);
	/*if (cpuInfo[0] >= 0x16)
	{
		__cpuid(cpuInfo, 0x16);
		Res = ((unsigned long long)cpuInfo[0]) * 1000000;
		GetTS = &rdtsc;
	}*/
	//else
	{

		GetTS = &GetQPC;
		QueryPerformanceFrequency((LARGE_INTEGER*)&Res);
		//This is a risky swamp, because CPUs with turbo boost enabled that doesn't have an invariant clock will cause the timer to run faster.
		//We need to resort to HPET timers in such cases, rather than rdtsc.
	}
	return (double)Res;
}

double TSFreq = GetTSFreq();
unsigned char	   PTPMasterClock[8];	//XX-XX-XX-FF-FE-XX-XX-XX

//Forward declarations
void SAPListener();
void MainLoop();


unsigned int GenerateIP()
{
	srand(__rdtsc() & ~0x0ul);
	//return (rand() & 0xFF) << 24 | (rand() & 0xFF) << 16 | (IPPrefix) << 8 | 239;
	return (1) << 24 | (0) << 16 | (69) << 8 | 239;
}

/*
	Sending packets needs to be done synchronized with the timer, and we want to do this as fast as possible
	Implementing an extra delay is going to cause complications for the transmission because it needs to be "snapped"
	to a frame.
	The easiest way to do this is therefore a second ringbuffer
*/

//Faster than a log10, used to add fraction to a float or double.
void numDigits(UINT64 number, UINT64 *OutCnt, UINT64 *OutFactor)
{
	if (number < 10)
	{
		*OutCnt = 1;
		*OutFactor = 1;
	}
	else if (number < 100)
	{
		*OutCnt = 2;
		*OutFactor = 10;
	}
	else if (number < 1000)
	{
		*OutCnt = 3;
		*OutFactor = 100;
	}
	else if (number < 10000)
	{
		*OutCnt = 4;
		*OutFactor = 1000;
	}
	else if (number < 100000)
	{
		*OutCnt = 5;
		*OutFactor = 10000;
	}
	else if (number < 1000000)
	{
		*OutCnt = 6;
		*OutFactor = 100000;
	}
	else if (number < 10000000)
	{
		*OutCnt = 7;
		*OutFactor = 1000000;
	}
	else if (number < 100000000)
	{
		*OutCnt = 8;
		*OutFactor = 10000000;
	}
	else if (number < 1000000000)
	{
		*OutCnt = 9;
		*OutFactor = 100000000;
	}
	else if (number < 10000000000)
	{
		*OutCnt = 10;
		*OutFactor = 1000000000;
	}
	else if (number < 100000000000)
	{
		*OutCnt = 11;
		*OutFactor = 10000000000;
	}
	else if (number < 1000000000000)
	{
		*OutCnt = 12;
		*OutFactor = 100000000000;
	}
	else if (number < 10000000000000)
	{
		*OutCnt = 13;
		*OutFactor = 1000000000000;
	}
	else if (number < 100000000000000)
	{
		*OutCnt = 14;
		*OutFactor = 10000000000000;
	}
	else if (number < 1000000000000000)
	{
		*OutCnt = 15;
		*OutFactor = 100000000000000;
	}
	else if (number < 10000000000000000)
	{
		*OutCnt = 16;
		*OutFactor = 1000000000000000;
	}
	else if (number < 100000000000000000)
	{
		*OutCnt = 17;
		*OutFactor = 10000000000000000;
	}
	else if (number < 1000000000000000000)
	{
		*OutCnt = 18;
		*OutFactor = 100000000000000000;
	}
	else
	{
		*OutCnt = 19;
		*OutFactor = 1000000000000000000;
	}
}


AOIP_API void SetDeviceName(const char* Dev)
{
	DevName = Dev;
}

void DecodeSession(SDP& Meta, char* Data)
{
	Meta.SDPData = Data + sizeof(SAP);
	Data += sizeof(SAP);
	Meta.SAPHeader = (SAP*) Meta.Raw;

	assert(*Data == 'v');

	char* Attr;

	while (*Data)
	{
		if (*((unsigned short*)Data) == 0x3d6f)
		{
			Data += 2; // '='

			//Skip Owner
			while (*Data != 0x20)
				++Data;
			++Data;

			//Skip session ID
			while (*Data != 0x20)
				++Data;
			++Data;

			//Skip session Version
			while (*Data != 0x20)
				++Data;
			++Data;

			Data += 7; //Skip "IN IP4 " !!!Warning: Only compatible with AES67

			Attr = Data;
			//End of chunk, delimited by 0x0a0d
			while (*((unsigned short*)Data) != 0x0a0d)
				++Data;
			*Data = 0;
			Data += 2;
			Meta.TransmitterIP = StringToIP(Attr);

		}
		if (*((unsigned short*)Data) == 0x3d73) //Faster Checks, Stream and test both bytes at once.//(*Data == 's' && *(++Data) == '=')	//Get Session name as device name "s="
		{
			Data += 2;

			Meta.DevName = Data;
			while (*((unsigned short*)Data) != 0x0a0d)
				++Data;
			*Data = 0;

			char* Str = Meta.DevName;

			Meta.DevName = (char*)malloc(strlen(Str) + 1);
			strcpy(Meta.DevName, Str);
			
			++Data;
		}
		if (*((unsigned short*)Data) == 0x3d63)
		{
			Data += 9;
			Attr = Data;
			while (*Data != 0x2f)
				++Data;
			*Data = 0;

			Meta.MultigroupIP = StringToIP(Attr);
			while (*((unsigned short*)Data) != 0x0a0d)
				++Data;

			Data += 2;
		}
		if (*((unsigned short*)Data) == 0x3d6d) //UTF-8 "m="
		{
			while (*Data != 0x20)
				++Data;
			++Data;

			Attr = Data;

			while (*Data != 0x20)
				++Data;
			*Data = 0;

			Meta.TransmitterPort = ToNum(Attr);

			while (*((unsigned short*)Data) != 0x0a0d) //Skip the checks in the mainloop for faster iteration.
				++Data;
			Data += 2;
		}
		if (*((unsigned short*)Data) == 0x3d69)	//i=
		{
			Data += 2;
			while (*Data != 0x20)
				++Data;
			++Data;
			Data += 10; //"Channels: "
			Attr = Data;
			while (*Data != 0x2C && *((unsigned short*)Data) != 0x0a0d)
				++Data;
			*Data = 0;
			//Assign numbers to literate channels
			//if (*Attr == 'L' || *Attr == 'R')
			//	Meta.ChannelOffset = 0;
			//else
		//		Meta.ChannelOffset = ToNum(Attr) - 1;
		}
		if (*((unsigned int*)Data) == 0x74723d61)	//"a=rt" for rtpmap. This is completely safe as long as we're on the stack, or we're not outside the 1k buffer
		{
			//RTPMap:97
			while (*Data != 0x20)
				++Data;
			++Data;


			//MIME Type
			++Data;
			Attr = Data;
			while (*Data != 0x2f)
				++Data;
			*Data = 0;
			Meta.ByteDepth = ToNum(Attr) / 8;
			++Data;

			Attr = Data;

			//Sample rate
			while (*Data != 0x2f)
				++Data;
			*Data = 0;
			Meta.SampleRate = ToNum(Attr);
			Meta.PackSamples = 0;	//We don't know this yet
			++Data;
			//Channels
			Attr = Data;
			while (*((unsigned short*)Data) != 0x0a0d)
				++Data;
			*Data = 0;
			Meta.Channels = ToNum(Attr);

			Data += 2;
		}
		++Data;
	}
}

struct
{
	SAP SAPData;
	char SDPBroadcast[300];	//This will be broadcasted for other devices to hear
} SDPTemplate;


AOIP_API void InitializeSAP(const char *IP)
{
	SAPIPAddr = StringToIP(IP);
}


typedef unsigned long long(*TSC)();

//Raw packet helpers

//Destination IP
unsigned int GetDstIP(const char* data)
{
	return (*((unsigned int*)(data + 30)));
}

unsigned int GetSrcIP(const char* data)
{
	return  (*((unsigned int*)(data + 26)));
}

unsigned short GetSrcPort(const char* data)
{
	return (*((unsigned short*)(data + 34)));
}

unsigned short GetDstPort(const char* data)
{
	return (*((unsigned short*)(data + 36)));
}

unsigned int GetTimestamp(const char* data)
{
	return ntohl(*((unsigned int*)(data + RTPTSOFFSET)));
}

SDP* GetStream(unsigned int IP)
{
	for (unsigned char i = 0; i < Index; ++i)
	{
		if (Streams[i].bFlags != S_PENDING_INIT && Streams[i].MultigroupIP == IP)
			return &Streams[i];
	}
	return nullptr;
}

static inline int ToInt(float x)
{
	//x += 1.f;
	return 8388608 * x;
}

static inline int ToInt16(float x)
{
	//x += 1.f;
	return 32767 * x;
}

int interpret24bitAsInt32(const unsigned char* byteArray) {
	return (
		(byteArray[0] << 24)
		| (byteArray[1] << 16)
		| (byteArray[2] << 8)
		) >> 8;
}
void DumpBytes(const unsigned char*, unsigned int);
static inline float ToFloat(int Sample)
{
	//return ((long long)Sample - 8388608) * (1.0 / 8388608);
//	DumpBytes((const unsigned char*)&Sample, 4);
	return (float)(((double)Sample) / 8388608.0);
	//return (((double)Sample) / 8388608.0) - 1.f;
}


void SAPListener()
{
	SetThreadAffinityMask(GetCurrentThread(), 1);	//Core #1
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
	printf("Listening for SAP\n");
	WSADATA wsaData;
	u_char loop = 0;

	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
	{
		printf("Server: WSAStartup failed for SAP with error %ld\n", WSAGetLastError());
		exit(-1);
	}

	SAPSocket = socket(AF_INET, SOCK_DGRAM, 0);

	if (SAPSocket == INVALID_SOCKET)
	{
		printf("Server read: Error at SAP socket() : %ld\n", WSAGetLastError());
		// Close the socket
		closesocket(SAPSocket);

		// Clean up
		WSACleanup();

		exit(-1);
	}

	SAPAddr.sin_addr.S_un.S_addr = SelectedInterface->IP;
	SAPAddr.sin_family = AF_INET;
	SAPAddr.sin_port = htons(9875);
	bool T = true;

	//Make sure that other applications can use this port too if they wish.
	if (setsockopt(SAPSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&T, sizeof(bool)) == SOCKET_ERROR)
	{
		printf("Server read: setsockopt() failed! Error : %ld.\n", WSAGetLastError());
		// Close the socket
		closesocket(SAPSocket);

		// Do the clean up
		WSACleanup();

		// and exit with error
		exit(-1);
	}

	//Make it non-blocking. EDIT: We're keeping it in a separate thread
	//unsigned long iMode = 1;
	//ioctlsocket(SAPSocket, FIONBIO, &iMode);

	if (bind(SAPSocket, (SOCKADDR*)&SAPAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		printf("Server read: bind() failed! Error : %ld.\n", WSAGetLastError());
		// Close the socket
		closesocket(SAPSocket);

		// Do the clean up
		WSACleanup();

		// and exit with error
		exit(-1);
	}


	//Let the kernel deal with IGMP
	struct ip_mreq mreq;
	memset(&mreq, 0, sizeof(ip_mreq));
	mreq.imr_multiaddr.s_addr = SAPIPAddr;
	mreq.imr_interface.s_addr = SelectedInterface->IP;
	if (setsockopt(SAPSocket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq)) == SOCKET_ERROR)
	{
		printf("Server read: setsockopt() add membership failed! Error : %ld. IP %lu\n", WSAGetLastError(), mreq.imr_multiaddr.s_addr);
		// Close the socket
		closesocket(SAPSocket);

		// Do the clean up
		WSACleanup();

		// and exit with error
		exit(-1);
	}
	//setsockopt(SAPSocket, IPPROTO_IP, IP_MULTICAST_IF, (char*)&mreq.imr_interface, sizeof(SOCKADDR_IN));

//#ifdef WIN32
//	DWORD timeout = 0;
//	setsockopt(SAPSocket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof timeout);
//#else

//#endif

	//disable loopback
	//u_char loop = 0;
	//setsockopt(SAPSocket, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&loop, sizeof(loop));
	printf("Listening for SAP data\n");
	unsigned long arg = 1;
	pcap_pkthdr *Header;
	//char Data[512];
	sockaddr_in addrin;
	int sz = sizeof(addrin);
	//The same device will be able to send a number of different SAP packets, one for each stream.
	while (true)
	{
		SDP &Stream = Streams[Index];
		//Start listening for SAP packets
		int Bytes = recvfrom(SAPSocket, Stream.Raw, 512, 0, (sockaddr*)&addrin, &sz);
		//int Status = pcap_next_ex(SAPlst, &Header, (const u_char**)&Data);

		//if (Header->len < 10 || ntohs(GetDstPort(Data)) != 9875)
		//	continue;
		//Fetch a new device block, this is a very fast way of avoiding any cross-thread locks

		Stream.Timestamp = 0;
		//We start by moving the data to an empty device, then check if the device already exists, if it does, then swap them, make sure that the device is invalid first, otherwise just discard the packet.

		Stream.Raw[Bytes] = 0;
		//Process
		if (addrin.sin_addr.S_un.S_addr == SelectedInterface->IP)
			goto END;

		//Data += (sizeof(Ethernet) + sizeof(IP4) + sizeof(UDPHeader));

		//Decode SDP block
		DecodeSession(Stream, Stream.Raw);
		//	bool bFound = false;
		Stream.TransmitterIP = addrin.sin_addr.S_un.S_addr;
		Stream.TransmitterPort = addrin.sin_port;
		//Don't add ourselves.



		//Check if stream already exists. Can be a stream that is reconnecting, or one that has been manually added, or simply already exists and is initialized.
		for (int i = 0; i < Index; ++i)
		{
			if (!strcmp(Streams[i].DevName, Stream.DevName))
			{
				if (Streams[i].bFlags & S_PENDING_INIT)
				{
					char* DN = Streams[i].DevName;
					int ChOff = Streams[i].ChannelOffset;

					/*Streams[i].FrameSamples = Stream.FrameSamples;
					Streams[i].MultigroupIP = Stream.MultigroupIP;
					Streams[i].PackSamples = Stream.PackSamples;
					Streams[i].SampleRate = Stream.SampleRate;
					//Streams[i].SessionID = Stream.SessionID;
					//Streams[i].SessionVer = Stream.SessionVer;
					Streams[i].TransmitterIP = Stream.TransmitterIP;
					Streams[i].TransmitterPort = Stream.TransmitterPort;
					Streams[i].SDPData = Streams[i].Raw + sizeof(SAP);
					Streams[i].SAPHeader = (SAP*)Streams[i].Raw;
					Streams[i].ByteDepth = Stream.ByteDepth;
					Streams[i].Channels = Stream.Channels;
					ChannelCount += Stream.Channels;*/

					memcpy(&Streams[i], &Stream, sizeof(SDP));
					Streams[i].DevName = DN;
					Streams[i].ChannelOffset = ChOff;
					//DecodeSession(Streams[i]);
					Stream.bFlags = S_INVALID;

					Streams[i].bFlags = S_WAIT_OPEN;

					union
					{
						unsigned int I;
						unsigned char IP[4];
					};
					I = Streams[i].MultigroupIP;

					if (Streams[i].Socket != INVALID_SOCKET)
						closesocket(Streams[i].Socket);

					Streams[i].Socket = socket(AF_INET, SOCK_DGRAM, 0);

					if (Streams[i].Socket == SOCKET_ERROR)
					{
						printf("Socket error: %i\n", WSAGetLastError());
						exit(1);
					}

					sockaddr_in binder;
					binder.sin_family = AF_INET;
					binder.sin_addr.S_un.S_addr = SelectedInterface->IP;
					binder.sin_port = htons(5004);

					if (setsockopt(Streams[i].Socket, SOL_SOCKET, SO_REUSEADDR, (char*)&T, sizeof(bool)) == SOCKET_ERROR)
					{
						printf("Server read: setsockopt() failed! Error : %ld.\n", WSAGetLastError());
						// Close the socket
						closesocket(SAPSocket);

						// Do the clean up
						WSACleanup();

						// and exit with error
						exit(-1);
					}

					if (bind(Streams[i].Socket, (sockaddr*)&binder, sizeof(binder)) == SOCKET_ERROR)
					{
						printf("Failed to bind: %i\n", WSAGetLastError());
						exit(1);
					}



					ioctlsocket(Streams[i].Socket, FIONBIO, &arg);

					struct ip_mreq mreq;
					memset(&mreq, 0, sizeof(ip_mreq));
					mreq.imr_multiaddr.s_addr = Streams[i].MultigroupIP;
					mreq.imr_interface.s_addr = SelectedInterface->IP;
					if (setsockopt(Streams[i].Socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq)) < 0)
					{
						printf("SAP Engine: failed to join multigroup %u.%u.%u.%u for stream %u at device %s reason : %ld\n", IP[0], IP[1], IP[2], IP[3], Stream.MultigroupIP, Stream.DevName, WSAGetLastError());

						// Do the clean up
						WSACleanup();

						// and exit with error
						exit(-1);
					}
					setsockopt(Streams[i].Socket, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&loop, sizeof(loop));

					printf("Sucessfully initialized stream %s %u.%u.%u.%u \n", Stream.DevName, IP[0], IP[1], IP[2], IP[3]);
					goto END;
				}
				else if (Streams[i].bFlags & S_OPEN || Streams[i].bFlags & S_WAIT_OPEN)	//Already done.
					goto END;
			}
		}

		//Need to add it
		if (Index > 0)
			Stream.ChannelOffset = Streams[Index - 1].ChannelOffset + Streams[Index - 1].Channels;
		else
			Stream.ChannelOffset = 0;
		ChannelCount += Stream.Channels;
		printf("Sucessfully added new stream %s\n", Stream.DevName);

		Stream.Socket = socket(AF_INET, SOCK_DGRAM, 0);

		if (Stream.Socket == SOCKET_ERROR)
		{
			printf("Socket error: %i\n", WSAGetLastError());
			exit(1);
		}

		sockaddr_in binder;
		binder.sin_family = AF_INET;
		binder.sin_addr.S_un.S_addr = SelectedInterface->IP;
		binder.sin_port = htons(5004);

		if (setsockopt(Stream.Socket, SOL_SOCKET, SO_REUSEADDR, (char*)&T, sizeof(bool)) == SOCKET_ERROR)
		{
			printf("Server read: setsockopt() failed! Error : %ld.\n", WSAGetLastError());
			// Close the socket
			closesocket(SAPSocket);

			// Do the clean up
			WSACleanup();

			// and exit with error
			exit(-1);
		}

		if (bind(Stream.Socket, (sockaddr*)&binder, sizeof(binder)) == SOCKET_ERROR)
		{
			printf("Failed to bind: %i\n", WSAGetLastError());
			exit(1);
		}

		ioctlsocket(Stream.Socket, FIONBIO, &arg);

		//Currently this is the only way Windows allows us to 
		struct ip_mreq mreq;
		memset(&mreq, 0, sizeof(ip_mreq));
		mreq.imr_multiaddr.s_addr = Stream.MultigroupIP;
		mreq.imr_interface.s_addr = SelectedInterface->IP;// StringToIP("192.168.15.98");
		if (setsockopt(Stream.Socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq)) < 0)
		{
			printf("SAP Engine: failed to join multigroup %u.%u.%u.%u for stream %u at device %s reason : %ld\n", ((unsigned char*)&Stream.MultigroupIP)[0], ((unsigned char*)&Stream.MultigroupIP)[1], ((unsigned char*)&Stream.MultigroupIP)[2], ((unsigned char*)&Stream.MultigroupIP)[3], Stream.MultigroupIP, Stream.DevName, WSAGetLastError());

			// Do the clean up
			WSACleanup();

			// and exit with error
			exit(-1);
		}


		setsockopt(Stream.Socket, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&loop, sizeof(loop));

	
		Stream.bFlags = S_WAIT_OPEN;
		++Index;
	END:
		;

	}
}

SOCKET SAPTrans;

unsigned char CharToNum(char Char)
{
	if (Char >= '0' && Char <= '9')
		return Char - '0';
	if (Char >= 'A' && Char <= 'F')
		return Char - 'A' + 10;
	if (Char >= 'a' && Char <= 'f')
		return Char - 'a' + 10;
}

bool CompareMAC(char* _MAC)
{
	unsigned char MAC[8];

	MAC[0] = (CharToNum(_MAC[1]) ) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	MAC[1] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3; 
	MAC[2] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	MAC[3] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	MAC[4] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	MAC[5] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	MAC[6] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	MAC[7] = (CharToNum(_MAC[1])) | (CharToNum(_MAC[0]) << 4);
	_MAC += 3;
	return memcmp(MAC, PTPMasterClock, 8);
}

void SAPTransmitter()
{
	SetThreadAffinityMask(GetCurrentThread(), 1);	//Core #1
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

	WSADATA wsaData;
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
	{
		printf("Server sender: WSAStartup failed for SAP with error %ld\n", WSAGetLastError());
		exit(-1);
	}

	SAPTrans = socket(AF_INET, SOCK_DGRAM, 0);

	if (SAPTrans == INVALID_SOCKET)
	{
		printf("Server sender: Error at SAP socket() : %ld\n", WSAGetLastError());
		// Close the socket
		closesocket(SAPTrans);

		// Clean up
		WSACleanup();

		exit(-1);
	}

	bool T = true;

	sockaddr_in inf = { 0 };
	inf.sin_addr.S_un.S_addr = SelectedInterface->IP;
	inf.sin_family = AF_INET;
	inf.sin_port = htons(9875);
	

	//Make sure that other applications can use this port too if they wish.
	if (setsockopt(SAPTrans, SOL_SOCKET, SO_REUSEADDR, (char*)&T, sizeof(bool)) < 0)
	{
		printf("Server sender: setsockopt() failed! Error : %ld.\n", WSAGetLastError());
		// Close the socket
		closesocket(SAPTrans);

		// Do the clean up
		WSACleanup();

		// and exit with error
		exit(-1);
	}

	//Make it non-blocking. EDIT: We're keeping it in a separate thread
	unsigned long iMode = 0;
	ioctlsocket(SAPTrans, FIONBIO, &iMode);
	int ttl = 1;
	setsockopt(SAPTrans, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ttl, 4);

	/*if (bind(SAPTrans, (SOCKADDR*)&inf, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		printf("Server: bind() failed! Error : %ld.\n", WSAGetLastError());
		// Close the socket
		closesocket(SAPTrans);

		// Do the clean up
		WSACleanup();

		// and exit with error
		exit(-1);
	}*/

	inf.sin_addr.S_un.S_addr = SAPIPAddr;// SelectedInterface->IP;

	int Mov = 0;
	//disable loopback
	//u_char loop = 0;
	//setsockopt(SAPSocket, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&loop, sizeof(loop));
	while (bSAPTrans)
	{
			for (unsigned char i = 0; i < NumTStreams; ++i)
			{
				//Figure out if some changes have been made to it
				if (CompareMAC(TransmissionStreams[i].PTPMac + 30))
				{
					TransmissionStreams[i].SDPData = TransmissionStreams[i].PTPMac;
					TransmissionStreams[i].SDPData += sprintf(TransmissionStreams[i].SDPData, "a=ts-refclk:ptp=IEEE1588-2008:%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X:0\x0d\x0a", PTPMasterClock[0], PTPMasterClock[1], PTPMasterClock[2], PTPMasterClock[3], PTPMasterClock[4], PTPMasterClock[5], PTPMasterClock[6], PTPMasterClock[7]);
					TransmissionStreams[i].SDPData += sprintf(TransmissionStreams[i].SDPData, "a=mediaclk:direct=0\x0d\x0a");
					++(*TransmissionStreams[i].SessionLoc);	
					TransmissionStreams[i].Size = TransmissionStreams[i].SDPData - TransmissionStreams[i].Raw;
					//This only works with values less than 10.
					//Mov = sprintf(TransmissionStreams[i].PTPMac, "%02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X", PTPMasterClock[0], PTPMasterClock[1], PTPMasterClock[2], PTPMasterClock[3], PTPMasterClock[4], PTPMasterClock[5], PTPMasterClock[6], PTPMasterClock[7]);
					//TransmissionStreams[i].PTPMac[Mov] = ':';
				}
				//printf("Sending %u %u PTPClk %s\n", i, TransmissionStreams[i].Size, TransmissionStreams[i].PTPMac);


				int s = sendto(SAPTrans, TransmissionStreams[i].Raw, TransmissionStreams[i].Size, 0, (sockaddr*)&inf, sizeof(sockaddr_in));
				if (s < 0)
					printf("Failed %u\n", WSAGetLastError());
			}
		Sleep(5000);
	}
	closesocket(SAPTrans);
	
}

AOIP_API Interface* GetInterfaces()
{
	static Interface Interfaces[64];
	int Index = 0;
	memset(Interfaces, 0, sizeof(Interfaces));

	PIP_ADAPTER_INFO MACS = (PIP_ADAPTER_INFO)alloca(256*4 );
	ZeroMemory(MACS, 256 * 4);
	unsigned long Sz = 256*4;

	if (GetAdaptersInfo(MACS, &Sz) == ERROR_BUFFER_OVERFLOW)
	{
		MACS = (PIP_ADAPTER_INFO)alloca(Sz);
	}
	GetAdaptersInfo(MACS, &Sz);
	pcap_if_t* Devs;

	if (pcap_findalldevs(&Devs, PCErr) == -1)
	{
		printf("Error: %s\n", PCErr);
		return nullptr;
	}
	for (pcap_if_t* d = Devs; d; d = d->next)
	{
		Interfaces[Index].Description = d->description;
		Interfaces[Index].Name = d->name;
		Interfaces[Index].Handle = d;
		for (pcap_addr_t *a = d->addresses; a; a = a->next)
		{
			if (a->addr->sa_family == AF_INET)
				Interfaces[Index].IP = ((sockaddr_in*)a->addr)->sin_addr.S_un.S_addr;
		}

		//We have to go look for it...
		for(PIP_ADAPTER_INFO inf = MACS; inf; inf = inf->Next)
		{
			if (StringToIP(inf->IpAddressList.IpAddress.String) == Interfaces[Index].IP)
			{
				memcpy(Interfaces[Index].MAC, inf->Address, 8);
				break;
			}
		}
		++Index;
	}
	return Interfaces;
}

AOIP_API SDP * getSDPStreams()
{
	return Streams;
}

AOIP_API unsigned char GetSDPCount()
{
	return Index;
}

//Useful function to dump a block of data to the console
void DumpBytes(const unsigned char* Bytes, unsigned int Len)
{
	for (int i = 0; i < Len; ++i)
	{
		printf("%02X ", *Bytes++);
	}
}


u_int16_t udp_sum_calc(uint16_t len_udp, u_int32_t src_ip, u_int32_t dst_ip,
	char unsigned * b) {
	uint16_t prot_udp = 17;
	uint16_t padd = 0;
	uint16_t word16;
	unsigned int sum;
	int i;
	uint16_t *buff;

	buff = (uint16_t *)b;

	// Find out if the length of data is even or odd number. If odd,
	// effectively add a zero padding byte at the end of packet

	padd = len_udp & 0x1;	//Much faster than division


	//initialize sum to zero
	sum = 0;

	// make 16 bit words out of every two adjacent 8 bit words and 
	// calculate the sum of all 16 bit words
	for (i = 0; i < len_udp - padd; i = i + 2) {
		word16 = (uint16_t)((*(b + i) << 8) & 0xFF00) + *(b + i + 1);
		sum += (unsigned long)word16;
	}

	// Need padding byte?  If so, the last byte of the packet
	// also needs to be added.
	if (padd) 
	{
		word16 = (uint16_t)((*(b + i) << 8) & 0xFF00);
		sum += (unsigned long)word16;
	}

	// add the UDP pseudo header which contains the IP source and
	// destinationn addresses
	word16 = src_ip & 0xFFFF;
	sum += word16;
	word16 = src_ip >> 16 & 0xFFFF;
	sum += word16;

	word16 = dst_ip & 0xFFFF;
	sum += word16;
	word16 = dst_ip >> 16 & 0xFFFF;
	sum += word16;

	// the protocol number and the length of the UDP packet  are
	// also in the pseudoheader.
	sum += prot_udp + len_udp;

	// keep only the last 16 bits of the 32 bit calculated sum and add the carries
	while (sum >> 16)
		sum = (sum & 0xFFFF) + (sum >> 16);

	// Take the one's complement of sum
	sum = ~sum;

	return ((uint16_t)sum);
}

uint16_t ip_checksum(void* vdata, size_t length) {
	// Cast the data pointer to one that can be indexed.
	char* data = (char*)vdata;

	// Initialise the accumulator.
	uint32_t acc = 0xffff;

	// Handle complete 16-bit blocks.
	for (size_t i = 0; i + 1 < length; i += 2) {
		uint16_t word;
		memcpy(&word, data + i, 2);
		acc += ntohs(word);
		if (acc > 0xffff) {
			acc -= 0xffff;
		}
	}

	// Handle any partial block at the end of the data.
	if (length & 1) {
		uint16_t word = 0;
		memcpy(&word, data + length - 1, 1);
		acc += ntohs(word);
		if (acc > 0xffff) {
			acc -= 0xffff;
		}
	}

	// Return the checksum in network byte order.
	return ~acc;
}

AOIP_API void CreateNewStream(const char* StreamName, unsigned char ChannelOffset, unsigned char NumChannels, unsigned char NumSamples, unsigned int SampleRate, unsigned int MultiIP)
{
	//Make sure stream doesn't already exist.
	for (int i = 0; i < NumTStreams; ++i)
	{
		if (!strcmp(StreamName, TransmissionStreams[i].DevName))
			return;
	}
	printf("Created new stream %s %i \n", StreamName, ChannelOffset);
	//Proceed
	SDP& Stream = TransmissionStreams[NumTStreams];
	Stream.Channels = NumChannels;
	Stream.ByteDepth = 3;	//Maybe we make this modifiable later
	Stream.PackSamples = NumSamples;
	Stream.SampleRate = SampleRate;
	Stream.Seq = 0;
	Stream.TransmitterIP = SelectedInterface->IP;
	Stream.MultigroupIP = (239) | (IPPrefix << 8) | (0 << 16) | (MultiIP << 24);// GenerateIP();
	Stream.TransmitterPort = 5004;
	Stream.ChannelOffset = ChannelOffset;

	Stream.Timestamp = 0;// rand() & 0xFFFF;

	Stream.SAPHeader = (SAP*)Stream.Raw;
	Stream.SAPHeader->AuthLen = 0;
	((unsigned char&)Stream.SAPHeader->Flags) = 0x20;
	Stream.SAPHeader->Hash = rand() & 0xFFFF;	//Very important for Dante controller! They will dismiss any SAP packets without Hash
	Stream.SAPHeader->SrcIP = Stream.TransmitterIP;
	memcpy(Stream.SAPHeader->Type, "application/sdp", 16);
	Stream.SDPData = Stream.Raw + sizeof(SAP);

	memcpy(Stream.SDPData, "v=0", 3);
	Stream.SDPData += 3;

	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	Stream.PacketRate = SampleRate / NumSamples;

	memcpy(Stream.SDPData, "o=- ", 4);

	Stream.SDPData += 4;

	Stream.SessionID = rand();
	Stream.SessionVer = 0;

	union
	{
		unsigned int IP;
		unsigned char Bytes[4];
	};

	IP = Stream.TransmitterIP;

	Stream.SDPData += sprintf(Stream.SDPData, "%i ", Stream.SessionID );
	Stream.SessionLoc = (char*)Stream.SDPData;
	Stream.SDPData += sprintf(Stream.SDPData, "%i IN IP4 %u.%u.%u.%u", Stream.SessionVer, Bytes[0], Bytes[1], Bytes[2], Bytes[3]);
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	Stream.SDPData += sprintf(Stream.SDPData, "s=%s", StreamName);
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	Stream.DevName = (char*)StreamName;

	IP = Stream.MultigroupIP;

	Stream.SDPData += sprintf(Stream.SDPData, "c=IN IP4 %u.%u.%u.%u/32", Bytes[0], Bytes[1], Bytes[2], Bytes[3]);
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	memcpy(Stream.SDPData, "t=0 0", 5);
	Stream.SDPData += 5;

	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	Stream.SDPData += sprintf(Stream.SDPData, "a=keywds:%s", DevName);
	//Stream.SDPData += 14;
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	Stream.SDPData += sprintf(Stream.SDPData, "m=audio %i RTP/AVP 103", Stream.TransmitterPort);
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;
	++ChannelOffset;
//	if (NumChannels < 3)
//	{
//		Stream.SDPData += sprintf(Stream.SDPData, "i=%u channels: Left, Right", NumChannels);
		//Stream.SDPData += sprintf(Stream.SDPData, "i=RAVENNA Send 1/0,RAVENNA Send 1/1");

	//}
	//else
	{
		Stream.SDPData += sprintf(Stream.SDPData, "i=%u channels: %02d", NumChannels, ChannelOffset);
		for (int i = 1; i < NumChannels; ++i)
		{
			Stream.SDPData += sprintf(Stream.SDPData, ", %02d", i + ChannelOffset);
		}
	}

	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	memcpy(Stream.SDPData, "a=recvonly", 10);
	Stream.SDPData += 10;
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	Stream.SDPData += sprintf(Stream.SDPData, "a=rtpmap:103 L24/%d/%d", SampleRate, NumChannels);
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;

	memcpy(Stream.SDPData, "a=ptime:1", 9);
	Stream.SDPData += 9;
	*Stream.SDPData++ = 0x0d;
	*Stream.SDPData++ = 0x0a;
	Stream.PTPMac = Stream.SDPData;
	Stream.SDPData += sprintf(Stream.SDPData, "a=ts-refclk:ptp=IEEE1588-2008:00-00-00-00-00-00-00-00:0\x0d\x0a");
	Stream.SDPData += sprintf(Stream.SDPData, "a=mediaclk:direct=%u\x0d\x0a", Stream.Timestamp);


	Stream.Size = Stream.SDPData - Stream.Raw;
	
	++NumTStreams;
	//Done?

	Stream.DataSize = (Stream.PackSamples * Stream.Channels * Stream.ByteDepth) + FRAMESIZE;
	Stream.SampleData = (unsigned char*)malloc(Stream.DataSize);
	
	//Prepare network packet
	FRAME* DataFrame = (FRAME*)Stream.SampleData;
	
	const char FrameData[] =
		"\x01\x00\x5e\x45\x95\x83\x00\x1d\xc1\x50\x73\x1b\x08\x00\x45\xb8" \
		"\x01\x48\x00\x00\x40\x00\x20\x11\x04\x1b\xc0\xa8\x0f\x61\xef\x45" \
		"\x95\x83\xf0\x00\x13\x8c\x01\x34\x8c\xdb\x80\x61\x8b\x0d\xa0\x8f" \
		"\xfa\x1e\x2d\xcd\x44\x60";
	memcpy(DataFrame, FrameData, sizeof(FrameData));

	//Copy MAC data

	//((int&)DataFrame->Eth.DestMAC[3]) = (SelectedInterface->IP & 0x7FFFFF);
	unsigned int MIP = htonl(Stream.MultigroupIP);
	DataFrame->Eth.DestMAC[3] = (MIP >> 16) & 0x7F;
	DataFrame->Eth.DestMAC[4] = (MIP >> 8);
	DataFrame->Eth.DestMAC[5] = (MIP);

	DataFrame->Eth.SrcMAC[0] = SelectedInterface->MAC[0];
	DataFrame->Eth.SrcMAC[1] = SelectedInterface->MAC[1];
	DataFrame->Eth.SrcMAC[2] = SelectedInterface->MAC[2];
	DataFrame->Eth.SrcMAC[3] = SelectedInterface->MAC[3];
	DataFrame->Eth.SrcMAC[4] = SelectedInterface->MAC[4];
	DataFrame->Eth.SrcMAC[5] = SelectedInterface->MAC[5];
	//IP4 Header
	DataFrame->IPHdr.DestIP = (Stream.MultigroupIP);
	DataFrame->IPHdr.Len = htons(Stream.DataSize - 14); //UDP Size
	DataFrame->IPHdr.SourceIP = SelectedInterface->IP;
	DataFrame->UDP.DestPort = htons(Stream.TransmitterPort);
	DataFrame->UDP.SourcePort = (rand() + 1024) & 0xFFFF;
	DataFrame->UDP.Len = htons(Stream.DataSize - 34);

	DataFrame->IPHdr.Checksum = 0;
	DataFrame->IPHdr.Checksum = htons(ip_checksum(&DataFrame->IPHdr, sizeof(IP4)));

	DataFrame->RTP.Type = 0x67;
	DataFrame->RTP.ssrc = rand();

	memset(Stream.SampleData + sizeof(FRAME), 0, Stream.DataSize - sizeof(FRAME));
}

AOIP_API void ClearTransmissionStreams()
{
	for (int i = 0; i < NumTStreams; ++i)
	{
		free(TransmissionStreams[i].SampleData);
		TransmissionStreams[i].SampleData = nullptr;
	}
	NumTStreams = 0;
}



AOIP_API void InitializeEngine(double _IntervalFreq, timer _Callback, unsigned char _SampleDelay, float (*Buffer))
{
	IntervalFreq = _IntervalFreq;
	Timer = _Callback;
	SampleDelay = _SampleDelay;
	OutBuffer = Buffer;
}

//std::atomic<bool> bTransmit (0);
std::atomic<bool> bSend (0);

void print_ip(unsigned int ip)
{
	unsigned char bytes[4];
	bytes[0] = ip & 0xFF;
	bytes[1] = (ip >> 8) & 0xFF;
	bytes[2] = (ip >> 16) & 0xFF;
	bytes[3] = (ip >> 24) & 0xFF;
	printf("%d.%d.%d.%d\n", bytes[3], bytes[2], bytes[1], bytes[0]);
}

extern "C" NTSYSAPI NTSTATUS NTAPI NtSetTimerResolution(ULONG DesiredResolution, BOOLEAN SetResolution, PULONG CurrentResolution);

//High-performing network loop
void MainLoop()
{

	//We don't care about hyperthreading because hyperthreading doesn't cause context switches in the kernel. So we want to set the affinity to one CPU regardless.
	//For more throughput, disable HyperThreading.
	int ThreadCount;
	TSC GetTimeStamp;
#ifdef WIN32
	SYSTEM_INFO si = { 0 };
	GetSystemInfo(&si);
	ThreadCount = si.dwNumberOfProcessors;
#else
	//TODO: Implement Linux
	ThreadCount = sysconf(_SC_NPROCESSORS_ONLN);
#endif

	if (ThreadCount >= 2)
	{
#ifdef WIN32
		if (!SetThreadAffinityMask(GetCurrentThread(), 4))
			printf("WARNING!!!! Failed to set CPU affinity %u\n", GetLastError());//Core #2
		SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
		if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
			printf("WARNING!!!! Failed to set priority\n");
#else

#endif
	}
	else
	{
		printf("Warning: You need a Dual core CPU or better to run this driver.\n");
		exit(1);
	}

	double TSCAbsInterval = (TSFreq / IntervalFreq);//1000000; //NanoSeconds // 1.0000000000000 / (double)IntervalFreq;//(double)TSCFreq / (double)IntervalFreq;	//Number of ticks per interval
	printf("TSCFreq %f, Packet time %f cycles\n", TSFreq, TSCAbsInterval);
	
	//Timer absolute values.
	double Start;// Moved to global scope
	double	Stop;
	double LocalDelta;
	double LocalTS = -1.0;

	/*int tr = 1;

	//Send socket
	SOCKET SendS = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);

	if (SendS == INVALID_SOCKET)
	{
		printf("Invalid socket : %i\n", WSAGetLastError());
		exit(-1);
	}
	if (setsockopt(SendS, IPPROTO_IP, IP_HDRINCL, (const char*)&tr, sizeof(tr)) < 0) 
	{
		exit(-1);
	}

	struct sockaddr_in sin;
	sin.sin_port = htons(5004);*/
	
	struct pcap_pkthdr pktheader;	//Not sure this is safe


	struct ip_mreq mreq;
	memset(&mreq, 0, sizeof(ip_mreq));
	mreq.imr_multiaddr.s_addr = StringToIP("224.0.1.129");
	mreq.imr_interface.s_addr = SelectedInterface->IP;// StringToIP("192.168.15.98");
	if (setsockopt(socket(AF_INET, SOCK_DGRAM, 0), IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq)) < 0)
	{
		printf("RTP Listener: setsockopt() add membership failed! Error : %ld. IP %lu\n", WSAGetLastError(), mreq.imr_multiaddr.s_addr);
		// and exit with error
		exit(-1);
	}

	pcap_pkthdr *Header;

	const unsigned char *Data;
	SDP * Stream = nullptr;
	
	while (Index < 1)	//Don't do anthing until we have at least one device.
		Sleep(2000);


	int Status = 0;


	int tr = 1;

	//Send socket
	SOCKET SendS = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);

	if (SendS == INVALID_SOCKET)
	{
		printf("Invalid socket : %i\n", WSAGetLastError());
		exit(-1);
	}
	if (setsockopt(SendS, IPPROTO_IP, IP_HDRINCL, (const char*)&tr, sizeof(tr)) < 0)
	{
		exit(-1);
	}
	int Opt = 10240;
	setsockopt(SendS, SOL_SOCKET, SO_SNDBUF, (char*)&Opt, 4);

	int Size = 0;
	int Sz = 4;
	getsockopt(SendS, SOL_SOCKET, SO_SNDBUF, (char*)&Size, &Sz);

	unsigned long arg = 1;
	ioctlsocket(SendS, FIONBIO, &arg);

	printf("Buffer size: %i\n", Size);
	struct sockaddr_in sin;
	sin.sin_port = htons(5004);
	
	const unsigned int IPMask = (239);// | IPPrefix << 8; //239.XX whatever subnet we want to accept
	Start = 0.0;
	Stop = 0;
	PTPTimeStamp = 0;

	const unsigned int SampleStep = 48;//(48000 / IntervalFreq);

	for (unsigned char i = 0; i < NumTStreams; ++i)
	{
		TransmissionStreams[i].Timestamp = 0;
		TransmissionStreams[i].Seq = 0;
	}
	//* (unsigned short*)(DelayReq + 72) = 0;
	printf("Listening to %s %f\n", SelectedInterface->Description, Start);

	int k = 1;
	while (k == 1)	//Clean out the buffer
	{
		k = pcap_next_ex(listener, &Header, &Data);

	}

	//Wait for PTP clock
	while (Start == 0.0) //We can't check for a litteral zero since it's not a binary number.
	{
		Status = pcap_next_ex(listener, &Header, &Data);

		//Wait for ptp packet

		if (Status != 1)
			continue;

		if (GetDstIP((const char*)Data) == ( (129 << 24) | (1 << 16) | (0 << 8) | 224) && Header->len == 86)
		{
			//Sync msg
			if (ntohs(GetDstPort((const char*)Data)) == 319)
			{
				//Update PTP Master address
				*((unsigned long long*)PTPMasterClock) = *((unsigned long long*)(Data + 20 + UDPPAYLOAD));
				
				//nanoseconds
				LocalTS = ((Header->ts.tv_sec) + ((double)Header->ts.tv_usec / 1000000.0));
			}
			//Follow up
			else if (ntohs(GetDstPort((const char*)Data)) == 320 && LocalTS > -1.0)
			{
				//Get follow up msg

				//NanoSeconds
				double TempTS = ntohl(*((unsigned int*)(Data + 82)));

				TempTS /= 1000000000.0;
				//Seconds
				TempTS += (ntohl(*((unsigned int*)(Data + 78))));

				//Calculate follow up delay
				double PGDelay = ((Header->ts.tv_sec) + ((double)Header->ts.tv_usec / 1000000.0)) - LocalTS;
				TempTS += PGDelay;
				Start = (TempTS * TSFreq);
				Stop = Start + TSCAbsInterval;

				LocalDelta = GetTS();
				LocalTS = -1.0;
			}
		}
	}
	unsigned short ReadIndex = 0;
		GStepperIndex = 0;
	unsigned char WriteIndex = 0;
	
	bool bShipped = true;
	double StartFactor = Start;

	//printf("PTP Timer at %u\n", ((unsigned int)(((Start / TSFreq) * 48000.0))));

	k = 1;
	while (k == 1)	//Clean out the buffer
	{
		k = pcap_next_ex(listener, &Header, &Data);
	}

	static int Hit = 0;
	static int Miss = 0;

	unsigned long long TestStart = GetTS();

#define E_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062f
	static unsigned int F = 0;
	bSend = false;
	//Run for 10 min to begin with
	while (bRTPMain)//	//Mainloop
	{
	/*	for (int i = 0; i < 48; ++i)
		{


			float Sample = sin((2.f * float(E_PI) * 500) / 48000 * F) * 0.25;
			
			for (int j = 0; j < ChannelCount; ++j)
			{
				ChannelData[j][GStepperIndex] = ToFloat(ToInt(Sample));
			}
			++F;

			++GStepperIndex;
			GStepperIndex &= 0x7F;

			if (F > 96)
				F = 0;
		}
		*/
		
		while (Start < Stop) //Frame loop 1ms typically
		{
			//If we have something to transmit, then transmit here
			//if (bSend)
		//	{
			//	unsigned long long TS1 = GetTS();
		//		bSend = false;

				//unsigned long long TempDelta = GetTS();
				//Start += (TempDelta - LocalDelta);	//Increment by delta time
				//LocalDelta = TempDelta;
				//unsigned long long TS1 = GetTS();
			/*	for (unsigned char i = 0; i < NumTStreams; ++i)
				{

						if (!TransmissionStreams[i].Timestamp)
						{
							unsigned long long TempDelta = GetTS();
							//Start += (TempDelta - LocalDelta);	//Increment by delta time
							//LocalDelta = TempDelta;
							TransmissionStreams[i].Timestamp = ((unsigned int)(((Start / TSFreq) * 48000.0)));
						}
						

					if (!TransmissionStreams[i].Timestamp)
						TransmissionStreams[i].Timestamp = ((unsigned int)(((Start / TSFreq) * 48000.0)));

					((FRAME*)TransmissionStreams[i].SampleData)->RTP.TS = htonl(TransmissionStreams[i].Timestamp);
					((FRAME*)TransmissionStreams[i].SampleData)->RTP.seq_num = htons(TransmissionStreams[i].Seq);
					((FRAME*)TransmissionStreams[i].SampleData)->UDP.CRC = 0;
					//((FRAME*)TransmissionStreams[i].SampleData)->UDP.CRC = htons(udp_sum_calc(TransmissionStreams[i].DataSize + sizeof(UDPHeader), ((FRAME*)TransmissionStreams[i].SampleData)->IPHdr.SourceIP, ((FRAME*)TransmissionStreams[i].SampleData)->IPHdr.DestIP, (unsigned char*)&((FRAME*)TransmissionStreams[i].SampleData)->UDP ));
					//if (bRTPTrans)	//Only transmit if desired

					//pcap_sendpacket(RTPpcap, TransmissionStreams[i].SampleData, TransmissionStreams[i].DataSize);
					sin.sin_family = AF_INET;
					sin.sin_addr.S_un.S_addr = TransmissionStreams[i].MultigroupIP;



					int ss = sendto(SendS, (char*)TransmissionStreams[i].SampleData + sizeof(Ethernet), TransmissionStreams[i].DataSize - sizeof(Ethernet), 0, (sockaddr*)&sin, sizeof(sin));
					if (ss < 0)
						printf("ERROR %i\n", WSAGetLastError());


					TransmissionStreams[i].Timestamp += 48;
					++TransmissionStreams[i].Seq;
				}*/
				//unsigned long long TS2 = GetTS();
				//printf("%.9f\n", ((double)(TS2 - TS1)) / TSFreq);
		//	}


			Status = pcap_next_ex(listener, &Header, &Data);
			if (Status == 1)
			{
				
				if (Header->len > 300 && htons(GetDstPort((char*)Data)) == 5004 && (Stream = GetStream(GetDstIP((const char*)Data))) != nullptr)
				{
					++Hit;
					if (Stream->bFlags & S_WAIT_OPEN)
					{
						//Calculate number of packets per second, and mark stream as ready.
						Stream->PackSamples = (((Header->len - PAYLOADOFFSET) / Stream->Channels) / 3 ); // (Stream->ByteDepth));
						Stream->FrameSamples = (Stream->SampleRate / Stream->PackSamples) / (int)IntervalFreq;	// (48000 / 48) / 1000 = 1 packet per frame. (48000 / 24) / 1000 = 2 packets per frame
						Stream->PacketIndex = 0;
						Stream->SampleIndex = 0;
						Stream->Timestamp = GetTimestamp((char*)Data);
						unsigned char Offset = (Stream->Timestamp % 48);	//Get the offset by modular remainder from the timestamp. This will be the starting point in the stream effectively
																							//This needs to be properly tested for smaller sample packets
						Stream->SampleIndex = 0;// Offset + GStepperIndex;

						//	Dante stores the samples as Sample1 channel 1 - n, sample2 channel 1 - n...
						//	We need to change that to channel 1: sample 1 - n, channel2 sample 1 - n...

						//This is going to be slower because it needs to be padded to 32 bits from 24
						Data += PAYLOADOFFSET;
						for (unsigned char i = 0; i < 48; ++i)
						{
							for (unsigned char j = 0; j < Stream->Channels; ++j)
							{	//TODO: Implement SSE2 to use 4 at once or even AVX512 if possible
								//printf("Before: ");
								//DumpBytes(&Data[(i * (Stream->Channels * 3)) + (j * 3)], 3);
								//printf("\nAfter: ");
								ChannelData[Stream->ChannelOffset + j][Stream->SampleIndex] = ToFloat(
								( Data[(i * (Stream->Channels * 3)) + (j * 3)		 ] << 24
									| Data[(i * (Stream->Channels * 3)) + (j * 3) + 1] << 16
									| Data[(i * (Stream->Channels * 3)) + (j * 3) + 2] << 8 ) >> 8 );	//Deal with endianness here.
								//printf("\n");
								
							}


							++Stream->SampleIndex;
							Stream->SampleIndex &= 0x7F;
						}
						Stream->bFlags = S_OPEN;
					}
					else if (Stream->bFlags & S_OPEN)
					{
						static int dr = 0;
						//Deal with dropped packets
						if (Stream->Timestamp + 48 < GetTimestamp((char*)Data))
						{
							Stream->SampleIndex += GetTimestamp((char*)Data) - (Stream->Timestamp + 48);
							Stream->SampleIndex &= 0x7F;
	//						printf("Dropped packets %u num %i     %u   -   %u\n", (GetTimestamp((char*)Data) - (Stream->Timestamp + 48)) / 48, dr++, GetTimestamp((char*)Data), Stream->Timestamp + 48);
						}
						else if (Stream->Timestamp + 48 > GetTimestamp((char*)Data))
						{
							printf("WOW! We didn't move 48 samples!\n");
						}

						//Add samples
						Stream->Timestamp += 48;// GetTimestamp((char*)Data);
						Data += PAYLOADOFFSET;
						for (short i = 0; i < 48; ++i)
						{
							for (short j = 0; j < Stream->Channels; ++j)
							{
								ChannelData[ Stream->ChannelOffset + j][Stream->SampleIndex] = ToFloat(
								( Data[(i * (Stream->Channels * 3)) + (j * 3)		 ] << 24
									| Data[(i * (Stream->Channels * 3)) + (j * 3) + 1] << 16
									| Data[(i * (Stream->Channels * 3)) + (j * 3) + 2] << 8 ) >> 8 
								);
								//ChannelData[Stream->ChannelOffset + j][Stream->SampleIndex] = ToFloat(
								//	ToInt(sin((2.f * float(E_PI) * 500) / 48000 * F))
								//) * 0.25;
								//++F;
							}
							++Stream->SampleIndex;
							Stream->SampleIndex &= 0x7F;
						}
						//if (F > 144)
						//	F = 0;
					}
				}

				//PTP sync
				else if (Header->len == 86)
				{
					++Hit;
					//Sync msg
					if (ntohs(GetDstPort((const char*)Data)) == 319)
					{
						//Update PTP Master address
						LocalTS =  ((Header->ts.tv_sec) + ((double)Header->ts.tv_usec / 1000000.0));
							//We need to calculate local delay
						*((unsigned long long*)PTPMasterClock) = *((unsigned long long*)(Data + 20 + UDPPAYLOAD));
					}

					//Follow up
					else if (ntohs(GetDstPort((const char*)Data)) == 320 && LocalTS > -1.0)
					{
						//NanoSeconds
						double TempTS = ntohl(*((unsigned int*)(Data + 82)));
						TempTS /= 1000000000.0;
						//Seconds
						TempTS += (ntohll(*((unsigned long long*)(Data + 76))) >> 16);

						//Calculate follow up delay
						double PGDelay =  ((Header->ts.tv_sec) + ((double)Header->ts.tv_usec / 1000000.0)) - LocalTS;
						//CurTS /= (double)TSFreq;
						TempTS += PGDelay;
						TempTS *= TSFreq;	//Convert to local clock
						//TempTS += PGDelay;
						//Only unsigned math
						//printf("Delta %.9f Propagation %.9f\n", (TempTS - Start) / TSFreq, PGDelay / TSFreq );

						Start = TempTS;
						LocalDelta = GetTS();
						LocalTS = -1.0;

					}
				}
			}
			
			FIN:
			unsigned long long TempDelta = GetTS();
			Start += (TempDelta - LocalDelta);	//Increment by delta time
			LocalDelta = TempDelta;
		}
		
	//	printf("Hit %i Miss %i\n", Hit, Miss);
	//	Hit = 0; Miss = 0;

	/*	for (unsigned char i = 0; i < NumTStreams; ++i)
		{

			if (!TransmissionStreams[i].Timestamp)
			{
				unsigned long long TempDelta = GetTS();
				Start += (TempDelta - LocalDelta);	//Increment by delta time
				LocalDelta = TempDelta;
				TransmissionStreams[i].Timestamp = ((unsigned int)(((Start / TSFreq) * 48000.0)));
			}
		}
		*/
		//Increment the frame sample index
		GStepperIndex += SampleStep;
		GStepperIndex &= 0x7F;
		Stop += TSCAbsInterval;
		

		//Send streams
	/*	if (ReadIndex != GStepperIndex)//(ReadIndex != GStepperIndex)	//Make sure we have data to process
		{

			//unsigned long long TS1 = GetTS();

			if (ReadIndex + 48 <= 128)
			{
				for (int i = 0; i < ChannelCount; ++i)
				{
					memcpy(OutBuffer + (i * 48), &ChannelData[i][ReadIndex], (48 * 4));
					//memset(&ChannelData[i][ReadIndex], 0, 48 * 4);
				}
			}
			else
			{
				int Delta = 128 - ReadIndex;
				for (int i = 0; i < ChannelCount; ++i)
				{
					memcpy(OutBuffer + (i * 48), &ChannelData[i][ReadIndex], (Delta * 4));
					memcpy(OutBuffer + (i * 48) + Delta, &ChannelData[i][0], ((48 - Delta) * 4));

					//memset(&ChannelData[i][ReadIndex],0 , (Delta * 4));
					//memset(&ChannelData[i][0], 0, ((48 - Delta) * 4));
				}

			}*/
			

		/*	for (int j = 0; j < 3; ++j)
			{
				for (int i = 0; i < ChannelCount; ++i)
				{
					memcpy(OutBuffer + (i * 48) + (j * 16), &ChannelData[i][ReadIndex], 16 * 4);
				}

				ReadIndex += 16;
				ReadIndex &= 0x7F;
			}
*/

			//unsigned long long TS2 = GetTS();
			//printf("%.9f\n", ((double)TS2 - (double)TS1) / TSFreq);

		//	Timer(ChannelCount);
		//	ReadIndex += 48;
		//	ReadIndex &= 0x7F;
		
			if (bSend)
			{
				bSend = false;
				unsigned long long TempDelta = GetTS();
				Start += (TempDelta - LocalDelta);	//Increment by delta time
				LocalDelta = TempDelta;

				//unsigned long long TS1 = GetTS();
				for (unsigned char i = 0; i < NumTStreams; ++i)
				{

					if (!TransmissionStreams[i].Timestamp)
					{

						TransmissionStreams[i].Timestamp = ((unsigned int)(((Start / TSFreq) * 48000.0)));
					}

					((FRAME*)TransmissionStreams[i].SampleData)->RTP.TS = htonl(TransmissionStreams[i].Timestamp);
					((FRAME*)TransmissionStreams[i].SampleData)->RTP.seq_num = htons(TransmissionStreams[i].Seq);
					((FRAME*)TransmissionStreams[i].SampleData)->UDP.CRC = 0;
					//((FRAME*)TransmissionStreams[i].SampleData)->UDP.CRC = htons(udp_sum_calc(TransmissionStreams[i].DataSize + sizeof(UDPHeader), ((FRAME*)TransmissionStreams[i].SampleData)->IPHdr.SourceIP, ((FRAME*)TransmissionStreams[i].SampleData)->IPHdr.DestIP, (unsigned char*)&((FRAME*)TransmissionStreams[i].SampleData)->UDP ));
					//if (bRTPTrans)	//Only transmit if desired

					sin.sin_family = AF_INET;
					sin.sin_addr.S_un.S_addr = TransmissionStreams[i].MultigroupIP;

					//	pcap_sendpacket(listener, TransmissionStreams[i].SampleData, TransmissionStreams[i].DataSize);
					int ss = sendto(SendS, (char*)TransmissionStreams[i].SampleData + sizeof(Ethernet), TransmissionStreams[i].DataSize - sizeof(Ethernet), 0, (sockaddr*)&sin, sizeof(sin));
					if (ss <= 0)
						printf("ERROR %i\n", WSAGetLastError());

					TransmissionStreams[i].Timestamp += 48;
					++TransmissionStreams[i].Seq;

					TestStart = GetTS();

				}

				unsigned long long TempDelta = GetTS();
				Start += (TempDelta - LocalDelta);	//Increment by delta time
				LocalDelta = TempDelta;
			}
			else if (F)
			{
				
				double TempDelta = GetTS();
				std::cout << std::setprecision(9);
				std::cout << "DSP wasn't completed in time! Delta" << ((TempDelta - (double)TestStart) / TSFreq) << "\n";
				TestStart = TempDelta;
			}
			F = 1;
	//	}
		


	}
	printf("LOOP ENDED\n");
}

bool bStop = false;

void SendData()
{
	unsigned int ReadIndex = 0;
	if (!SetThreadAffinityMask(GetCurrentThread(), 1 << 3))
		printf("WARNING!!!! Failed to set CPU affinity %u\n", GetLastError());//Core #2
	SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
	if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST))
		printf("WARNING!!!! Failed to set priority\n");

/*	int tr = 1;

	//Send socket
	SOCKET SendS = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);

	if (SendS == INVALID_SOCKET)
	{
		printf("Invalid socket : %i\n", WSAGetLastError());
		exit(-1);
	}
	if (setsockopt(SendS, IPPROTO_IP, IP_HDRINCL, (const char*)&tr, sizeof(tr)) < 0)
	{
		exit(-1);
	}
	int Opt = 10240;
	setsockopt(SendS, SOL_SOCKET, SO_SNDBUF, (char*)&Opt, 4);

	int Size = 0;
	int Sz = 4;
	getsockopt(SendS, SOL_SOCKET, SO_SNDBUF,(char*) &Size, &Sz);

	unsigned long arg = 1;
	ioctlsocket(SendS, FIONBIO, &arg);

	printf("Buffer size: %i\n", Size);
	struct sockaddr_in sin;
	sin.sin_port = htons(5004);
	*/
	while (!bStop)
	{
		//Sleep(0);
		if (ReadIndex != GStepperIndex)//(ReadIndex != GStepperIndex)	//Make sure we have data to process
		{
			//unsigned long long TS1 = GetTS();

			if (ReadIndex + 48 <= 128)
			{
				for (int i = 0; i < ChannelCount; ++i)
				{
					memcpy(OutBuffer + (i * 48), &ChannelData[i][ReadIndex], (48 * 4));
					//memset(&ChannelData[i][ReadIndex], 0, 48 * 4);
				}
			}
			else
			{
				int Delta = 128 - ReadIndex;
				for (int i = 0; i < ChannelCount; ++i)
				{
					memcpy(OutBuffer + (i * 48), &ChannelData[i][ReadIndex], (Delta * 4));
					memcpy(OutBuffer + (i * 48) + Delta, &ChannelData[i][0], ((48 - Delta) * 4));

					//memset(&ChannelData[i][ReadIndex],0 , (Delta * 4));
					//memset(&ChannelData[i][0], 0, ((48 - Delta) * 4));
				}

			}


			/*for (int j = 0; j < 3; ++j)
			{
				for (int i = 0; i < ChannelCount; ++i)
				{
					memcpy(OutBuffer + (i * 48) + (j * 16), &ChannelData[i][ReadIndex], 16 * 4);
				}

				ReadIndex += 16;
				ReadIndex &= 0x7F;
			}*/


			//unsigned long long TS2 = GetTS();
			//printf("%.9f\n", ((double)TS2 - (double)TS1) / TSFreq);

			Timer(ChannelCount);
			bSend = true;
			ReadIndex += 48;
			ReadIndex &= 0x7F;

		}
	}
}


std::thread Transm;

struct bpf_program fcode;

AOIP_API void BeginSAPTransmission()
{
	if (bSAPTrans)
		return;
	std::thread SAPTrans(&SAPTransmitter);
	bSAPTrans = true;
	SAPTrans.detach();
}

AOIP_API void EndSAPTransmission()
{
	bSAPTrans = false;
}

AOIP_API void BeginSAP()
{
	if (bSAPMain)
		return;
	bSAPMain = true;
	///////C++11 threads are really weak.
	SAPThread = std::thread(&SAPListener);
	SAPThread.detach();
}

AOIP_API void EndSAP()
{
	bSAPMain = false;
}

AOIP_API void BeginRTPRecv()
{
	if (bRTPMain)
		return;	//Already running
	bRTPMain = true;
	RTPThread = std::thread(&MainLoop);
	RTPThread.detach();

	bStop = false;
	Transm = std::thread(&SendData);
	Transm.detach();
}

AOIP_API void EndRTPRecv()
{
	bRTPMain = false;
	bStop = true;
}

AOIP_API void SetIPPrefix(unsigned char IP)
{
	IPPrefix = IP;
}

AOIP_API unsigned char * GetTxBuffer(unsigned char _Index)
{
	return TransmissionStreams[_Index].SampleData + FRAMESIZE;
}




AOIP_API void InitializeIf(Interface* _If)
{
	bool bRestart = false;

	if (!_If->Handle)
	{
		//Invalid
		printf("Fatal error: Interface invalid\n");
		return;
	}

	if (SelectedInterface != nullptr && _If->IP == SelectedInterface->IP)
		return;

	//Stop driver
	if (bRTPMain || bSAPMain || bSAPTrans)
	{
		//Dispose old handle
		pcap_close(listener);
		pcap_close(SAPlst);

		EndSAP();
		EndRTPRecv();
		EndSAPTransmission();
		Sleep(20);	//Wait for the threads to stop
		bRestart = true;
	}
	
	
	

	SelectedInterface = _If;

	union
	{
		unsigned int I;
		unsigned char IP[4];
	};

	I = _If->IP;

	printf("Selected interface: %s (%s) IP %u.%u.%u.%u  MAC %02X-%02X-%02X-%02X-%02X-%02X\n", _If->Description, _If->Name, IP[0], IP[1], IP[2], IP[3], _If->MAC[0], _If->MAC[1], _If->MAC[2], _If->MAC[3], _If->MAC[4], _If->MAC[5]);
	//Open PCAP socket
	if ((listener = pcap_create(SelectedInterface->Name, PCErr)) == NULL)
	{
		printf("Error: %s\n", PCErr);
		exit(1);
	}

	if ((RTPpcap = pcap_create(SelectedInterface->Name, PCErr)) == NULL)
	{
		printf("Error: %s\n", PCErr);
		exit(1);
	}

	if ((SAPlst = pcap_create(SelectedInterface->Name, PCErr)) == NULL)
	{
		printf("Error: %s\n", PCErr);
		exit(1);
	}

	if (pcap_set_immediate_mode(listener, true) < 0)
	{
		printf("Error: Failed to set immediate mode\n");
		exit(1);
	}

	if (pcap_set_immediate_mode(RTPpcap, true) < 0)
	{
		printf("Error: Failed to set immediate mode\n");
		exit(1);
	}

	if (pcap_set_immediate_mode(SAPlst, true) < 0)
	{
		printf("Error: Failed to set immediate mode\n");
		exit(1);
	}
	//pcap_set_promisc(listener, 1);
	//pcap_set_buffer_size(listener, 100097152);
	int Val;
	if ((Val = pcap_activate(listener)) < 0)
	{
		printf("Error: %u\n", Val);
		exit(1);
	}
	if (Val > 0)
		printf("Warning: %u\n", Val);

	if (pcap_datalink(listener) != DLT_EN10MB)
	{
		printf("Warning: This driver only operates on Ethernet based interfaces\nEngine deinitialized\n");
		exit(1);
	}

	if ((Val = pcap_activate(SAPlst)) < 0)
	{
		printf("Error: %u\n", Val);
		exit(1);
	}
	if (Val > 0)
		printf("Warning: %u\n", Val);

	if ((Val = pcap_activate(RTPpcap)) < 0)
	{
		printf("Error: %u\n", Val);
		exit(1);
	}
	if (Val > 0)
		printf("Warning: %u\n", Val);

	unsigned int Netmask;
	if (((pcap_if_t*)SelectedInterface->Handle)->addresses)
		Netmask = ((SOCKADDR_IN*)((pcap_if_t*)SelectedInterface->Handle)->addresses->netmask)->sin_addr.S_un.S_addr;
	else
		Netmask = 0xFFFFFFFF;

	char Filter[128];
	sprintf(Filter, "ip multicast and src not %u.%u.%u.%u and (dst net 239 or dst net 224)", IP[0], IP[1], IP[2], IP[3]);
	
	if (pcap_compile(listener, &fcode, Filter, 1, Netmask) < 0)
	{
		printf("Error: Filter syntax\n");
		exit(1);
	}

	if (pcap_setfilter(listener, &fcode) < 0)
	{
		printf("Error: failed to apply filter\n");
		exit(1);
	}

	if (pcap_setfilter(SAPlst, &fcode) < 0)
	{
		printf("Error: failed to apply filter\n");
		exit(1);
	}

	if (pcap_setfilter(RTPpcap, &fcode) < 0)
	{
		printf("Error: failed to apply filter\n");
		exit(1);
	}
	//SAP will be blocking
	if (pcap_setnonblock(listener, 1, PCErr) < 0)
	{
		printf("Failed to set listener non-blocking %s\n", PCErr);
		exit(1);
	}

	if (pcap_setnonblock(RTPpcap, 1, PCErr) < 0)
	{
		printf("Failed to set listener non-blocking %s\n", PCErr);
		exit(1);
	}

	if (pcap_setnonblock(SAPlst, 0, PCErr) < 0)
	{
		printf("Failed to set listener non-blocking %s\n", PCErr);
		exit(1);
	}

	if (bRestart)
	{
		//Restart
		BeginSAP();
		BeginSAPTransmission();
		BeginRTPRecv();
	}
}

void AddStream(char* StreamName, unsigned char ChannelOffset)
{
	for (int i = 0; i < Index; ++i)
	{
		if (!strcmp(Streams[i].DevName, StreamName))
		{
			Streams[i].ChannelOffset = ChannelOffset;
			Streams[i].bFlags = S_WAIT_OPEN;
			return;
		}

	}
	
	SDP &S = Streams[Index];
	int Len = strlen(StreamName);
	S.DevName = (char*)malloc(Len + 1);
	memcpy(S.DevName, StreamName, Len);
	S.DevName[Len] = '\0';
	S.ChannelOffset = ChannelOffset;
	S.bFlags = S_PENDING_INIT;
	++Index;
}

AOIP_API void DelayUS(unsigned int usec)
{
	double TS = GetTS();
	unsigned long long i = 0;
	while ((((double)GetTS() - TS) / TSFreq) < ((double)usec * 0.000001))
	{
		++i;	//Just do something
	}
}
